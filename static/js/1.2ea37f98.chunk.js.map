{"version":3,"sources":["../node_modules/react-router/node_modules/path-to-regexp/index.js","../node_modules/react-router/node_modules/isarray/index.js","../node_modules/react-router/es/matchPath.js","../node_modules/react-router/es/Route.js","../node_modules/react-router-dom/es/Route.js","../node_modules/react-router-dom/es/Link.js","utilities/index.js","containers/Menu/Menu.js"],"names":["isarray","__webpack_require__","module","exports","pathToRegexp","parse","compile","str","options","tokensToFunction","tokensToRegExp","PATH_REGEXP","RegExp","join","res","tokens","key","index","path","defaultDelimiter","delimiter","exec","m","escaped","offset","slice","length","next","prefix","name","capture","group","modifier","asterisk","push","partial","repeat","optional","pattern","escapeGroup","escapeString","substr","encodeURIComponentPretty","encodeURI","replace","c","charCodeAt","toString","toUpperCase","matches","Array","i","obj","opts","data","encode","pretty","encodeURIComponent","token","segment","value","TypeError","JSON","stringify","j","test","attachKeys","re","keys","flags","sensitive","strict","end","route","endsWithDelimiter","groups","source","match","regexpToRegexp","parts","arrayToRegexp","stringToRegexp","isArray","arr","Object","prototype","call","patternCache","cacheCount","es_matchPath","pathname","arguments","undefined","parent","_options","_options$exact","exact","_options$strict","_options$sensitive","_compilePath","cacheKey","cache","compiledPattern","path_to_regexp_default","matchPath_compilePath","url","values","isExact","params","reduce","memo","_extends","assign","target","hasOwnProperty","_possibleConstructorReturn","self","ReferenceError","Route_isEmptyChildren","children","react_default","a","Children","count","Route_Route","_React$Component","Route","_temp","_this","instance","Constructor","_classCallCheck","this","_len","args","_key","apply","concat","state","computeMatch","props","context","router","subClass","superClass","create","constructor","enumerable","writable","configurable","setPrototypeOf","__proto__","_inherits","getChildContext","location","_ref","computedMatch","browser_default","componentWillMount","warning_default","component","render","componentWillReceiveProps","nextProps","nextContext","setState","_props","_context$router","history","staticContext","createElement","only","Component","propTypes","prop_types_default","object","string","bool","func","oneOfType","node","contextTypes","shape","isRequired","childContextTypes","react_router_dom_es_Route","Link_extends","Link_possibleConstructorReturn","isModifiedEvent","event","metaKey","altKey","ctrlKey","shiftKey","Link_Link","Link","Link_classCallCheck","handleClick","onClick","defaultPrevented","button","preventDefault","_this$props","to","Link_inherits","innerRef","indexOf","_objectWithoutProperties","es","href","createHref","ref","defaultProps","es_Link","utilities","capitalize","concatComponentPath","pathFromCurrentFile","NAV_NAMES","Slack","lazy","Promise","all","e","then","bind","Menu","Fragment","react","fallback","className","map"],"mappings":"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","file":"static/js/1.2ea37f98.chunk.js","sourcesContent":["var isarray = require('isarray');\n/**\n * Expose `pathToRegexp`.\n */\n\n\nmodule.exports = pathToRegexp;\nmodule.exports.parse = parse;\nmodule.exports.compile = compile;\nmodule.exports.tokensToFunction = tokensToFunction;\nmodule.exports.tokensToRegExp = tokensToRegExp;\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\n\nvar PATH_REGEXP = new RegExp([// Match escaped characters that would otherwise appear in future matches.\n// This allows the user to escape special characters that won't transform.\n'(\\\\\\\\.)', // Match Express-style parameters and un-named parameters with a prefix\n// and optional suffixes. Matches appear as:\n//\n// \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n// \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n// \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n'([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'].join('|'), 'g');\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\n\nfunction parse(str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var defaultDelimiter = options && options.delimiter || '/';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length; // Ignore already escaped sequences.\n\n    if (escaped) {\n      path += escaped[1];\n      continue;\n    }\n\n    var next = str[index];\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var modifier = res[6];\n    var asterisk = res[7]; // Push the current path onto the tokens.\n\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var partial = prefix != null && next != null && next !== prefix;\n    var repeat = modifier === '+' || modifier === '*';\n    var optional = modifier === '?' || modifier === '*';\n    var delimiter = res[2] || defaultDelimiter;\n    var pattern = capture || group;\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'\n    });\n  } // Match any characters still remaining.\n\n\n  if (index < str.length) {\n    path += str.substr(index);\n  } // If the path exists, push it onto the end.\n\n\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens;\n}\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\n\n\nfunction compile(str, options) {\n  return tokensToFunction(parse(str, options));\n}\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\n\n\nfunction encodeURIComponentPretty(str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\n\n\nfunction encodeAsterisk(str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\n\n\nfunction tokensToFunction(tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length); // Compile all the patterns before compilation.\n\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n    }\n  }\n\n  return function (obj, opts) {\n    var path = '';\n    var data = obj || {};\n    var options = opts || {};\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n        continue;\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix;\n          }\n\n          continue;\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined');\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`');\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue;\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty');\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`');\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue;\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"');\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path;\n  };\n}\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\n\n\nfunction escapeString(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1');\n}\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\n\n\nfunction escapeGroup(group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1');\n}\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\n\n\nfunction attachKeys(re, keys) {\n  re.keys = keys;\n  return re;\n}\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\n\n\nfunction flags(options) {\n  return options.sensitive ? '' : 'i';\n}\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\n\n\nfunction regexpToRegexp(path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys);\n}\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\n\n\nfunction arrayToRegexp(path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n  return attachKeys(regexp, keys);\n}\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\n\n\nfunction stringToRegexp(path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\n\n\nfunction tokensToRegExp(tokens, keys, options) {\n  if (!isarray(keys)) {\n    options =\n    /** @type {!Object} */\n    keys || options;\n    keys = [];\n  }\n\n  options = options || {};\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = ''; // Iterate over the tokens and create our regexp string.\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = '(?:' + token.pattern + ')';\n      keys.push(token);\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = prefix + '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/');\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter; // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys);\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\n\n\nfunction pathToRegexp(path, keys, options) {\n  if (!isarray(keys)) {\n    options =\n    /** @type {!Object} */\n    keys || options;\n    keys = [];\n  }\n\n  options = options || {};\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path,\n    /** @type {!Array} */\n    keys);\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(\n    /** @type {!Array} */\n    path,\n    /** @type {!Array} */\n    keys, options);\n  }\n\n  return stringToRegexp(\n  /** @type {string} */\n  path,\n  /** @type {!Array} */\n  keys, options);\n}","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};","import pathToRegexp from \"path-to-regexp\";\nvar patternCache = {};\nvar cacheLimit = 10000;\nvar cacheCount = 0;\n\nvar compilePath = function compilePath(pattern, options) {\n  var cacheKey = \"\" + options.end + options.strict + options.sensitive;\n  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\n  if (cache[pattern]) return cache[pattern];\n  var keys = [];\n  var re = pathToRegexp(pattern, keys, options);\n  var compiledPattern = {\n    re: re,\n    keys: keys\n  };\n\n  if (cacheCount < cacheLimit) {\n    cache[pattern] = compiledPattern;\n    cacheCount++;\n  }\n\n  return compiledPattern;\n};\n/**\n * Public API for matching a URL pathname to a path pattern.\n */\n\n\nvar matchPath = function matchPath(pathname) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var parent = arguments[2];\n  if (typeof options === \"string\") options = {\n    path: options\n  };\n  var _options = options,\n      path = _options.path,\n      _options$exact = _options.exact,\n      exact = _options$exact === undefined ? false : _options$exact,\n      _options$strict = _options.strict,\n      strict = _options$strict === undefined ? false : _options$strict,\n      _options$sensitive = _options.sensitive,\n      sensitive = _options$sensitive === undefined ? false : _options$sensitive;\n  if (path == null) return parent;\n\n  var _compilePath = compilePath(path, {\n    end: exact,\n    strict: strict,\n    sensitive: sensitive\n  }),\n      re = _compilePath.re,\n      keys = _compilePath.keys;\n\n  var match = re.exec(pathname);\n  if (!match) return null;\n  var url = match[0],\n      values = match.slice(1);\n  var isExact = pathname === url;\n  if (exact && !isExact) return null;\n  return {\n    path: path,\n    // the path pattern used to match\n    url: path === \"/\" && url === \"\" ? \"/\" : url,\n    // the matched portion of the URL\n    isExact: isExact,\n    // whether or not we matched exactly\n    params: keys.reduce(function (memo, key, index) {\n      memo[key.name] = values[index];\n      return memo;\n    }, {})\n  };\n};\n\nexport default matchPath;","var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport warning from \"warning\";\nimport invariant from \"invariant\";\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport matchPath from \"./matchPath\";\n\nvar isEmptyChildren = function isEmptyChildren(children) {\n  return React.Children.count(children) === 0;\n};\n/**\n * The public API for matching a single path and rendering.\n */\n\n\nvar Route = function (_React$Component) {\n  _inherits(Route, _React$Component);\n\n  function Route() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Route);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {\n      match: _this.computeMatch(_this.props, _this.context.router)\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  Route.prototype.getChildContext = function getChildContext() {\n    return {\n      router: _extends({}, this.context.router, {\n        route: {\n          location: this.props.location || this.context.router.route.location,\n          match: this.state.match\n        }\n      })\n    };\n  };\n\n  Route.prototype.computeMatch = function computeMatch(_ref, router) {\n    var computedMatch = _ref.computedMatch,\n        location = _ref.location,\n        path = _ref.path,\n        strict = _ref.strict,\n        exact = _ref.exact,\n        sensitive = _ref.sensitive;\n    if (computedMatch) return computedMatch; // <Switch> already computed the match for us\n\n    invariant(router, \"You should not use <Route> or withRouter() outside a <Router>\");\n    var route = router.route;\n    var pathname = (location || route.location).pathname;\n    return matchPath(pathname, {\n      path: path,\n      strict: strict,\n      exact: exact,\n      sensitive: sensitive\n    }, route.match);\n  };\n\n  Route.prototype.componentWillMount = function componentWillMount() {\n    warning(!(this.props.component && this.props.render), \"You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored\");\n    warning(!(this.props.component && this.props.children && !isEmptyChildren(this.props.children)), \"You should not use <Route component> and <Route children> in the same route; <Route children> will be ignored\");\n    warning(!(this.props.render && this.props.children && !isEmptyChildren(this.props.children)), \"You should not use <Route render> and <Route children> in the same route; <Route children> will be ignored\");\n  };\n\n  Route.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {\n    warning(!(nextProps.location && !this.props.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no \"location\" prop and then provided one on a subsequent render.');\n    warning(!(!nextProps.location && this.props.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a \"location\" prop initially but omitted it on a subsequent render.');\n    this.setState({\n      match: this.computeMatch(nextProps, nextContext.router)\n    });\n  };\n\n  Route.prototype.render = function render() {\n    var match = this.state.match;\n    var _props = this.props,\n        children = _props.children,\n        component = _props.component,\n        render = _props.render;\n    var _context$router = this.context.router,\n        history = _context$router.history,\n        route = _context$router.route,\n        staticContext = _context$router.staticContext;\n    var location = this.props.location || route.location;\n    var props = {\n      match: match,\n      location: location,\n      history: history,\n      staticContext: staticContext\n    };\n    if (component) return match ? React.createElement(component, props) : null;\n    if (render) return match ? render(props) : null;\n    if (typeof children === \"function\") return children(props);\n    if (children && !isEmptyChildren(children)) return React.Children.only(children);\n    return null;\n  };\n\n  return Route;\n}(React.Component);\n\nRoute.propTypes = {\n  computedMatch: PropTypes.object,\n  // private, from <Switch>\n  path: PropTypes.string,\n  exact: PropTypes.bool,\n  strict: PropTypes.bool,\n  sensitive: PropTypes.bool,\n  component: PropTypes.func,\n  render: PropTypes.func,\n  children: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),\n  location: PropTypes.object\n};\nRoute.contextTypes = {\n  router: PropTypes.shape({\n    history: PropTypes.object.isRequired,\n    route: PropTypes.object.isRequired,\n    staticContext: PropTypes.object\n  })\n};\nRoute.childContextTypes = {\n  router: PropTypes.object.isRequired\n};\nexport default Route;","// Written in this round about way for babel-transform-imports\nimport Route from \"react-router/es/Route\";\nexport default Route;","var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport invariant from \"invariant\";\nimport { createLocation } from \"history\";\n\nvar isModifiedEvent = function isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n};\n/**\n * The public API for rendering a history-aware <a>.\n */\n\n\nvar Link = function (_React$Component) {\n  _inherits(Link, _React$Component);\n\n  function Link() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Link);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (event) {\n      if (_this.props.onClick) _this.props.onClick(event);\n\n      if (!event.defaultPrevented && // onClick prevented default\n      event.button === 0 && // ignore everything but left clicks\n      !_this.props.target && // let browser handle \"target=_blank\" etc.\n      !isModifiedEvent(event) // ignore clicks with modifier keys\n      ) {\n          event.preventDefault();\n          var history = _this.context.router.history;\n          var _this$props = _this.props,\n              replace = _this$props.replace,\n              to = _this$props.to;\n\n          if (replace) {\n            history.replace(to);\n          } else {\n            history.push(to);\n          }\n        }\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  Link.prototype.render = function render() {\n    var _props = this.props,\n        replace = _props.replace,\n        to = _props.to,\n        innerRef = _props.innerRef,\n        props = _objectWithoutProperties(_props, [\"replace\", \"to\", \"innerRef\"]); // eslint-disable-line no-unused-vars\n\n\n    invariant(this.context.router, \"You should not use <Link> outside a <Router>\");\n    invariant(to !== undefined, 'You must specify the \"to\" property');\n    var history = this.context.router.history;\n    var location = typeof to === \"string\" ? createLocation(to, null, null, history.location) : to;\n    var href = history.createHref(location);\n    return React.createElement(\"a\", _extends({}, props, {\n      onClick: this.handleClick,\n      href: href,\n      ref: innerRef\n    }));\n  };\n\n  return Link;\n}(React.Component);\n\nLink.propTypes = {\n  onClick: PropTypes.func,\n  target: PropTypes.string,\n  replace: PropTypes.bool,\n  to: PropTypes.oneOfType([PropTypes.string, PropTypes.object]).isRequired,\n  innerRef: PropTypes.oneOfType([PropTypes.string, PropTypes.func])\n};\nLink.defaultProps = {\n  replace: false\n};\nLink.contextTypes = {\n  router: PropTypes.shape({\n    history: PropTypes.shape({\n      push: PropTypes.func.isRequired,\n      replace: PropTypes.func.isRequired,\n      createHref: PropTypes.func.isRequired\n    }).isRequired\n  }).isRequired\n};\nexport default Link;","export default (function() {\n    /*\n        @param: {string} name\n        @returns: {string} name capitalized\n    */\n    const capitalize = name => name[0].toUpperCase().concat(name.slice(1));\n\n    /*\n        @param: {string} path to component excluding component name (ignore trailing '/')\n        @returns: a function that accepts\n    */\n    const concatComponentPath = (pathFromCurrentFile, name) => `${pathFromCurrentFile}${capitalize(name)}/${capitalize(name)}`;\n\n    return {\n        concatComponentPath,\n        capitalize\n    };\n})();\n","import React, { lazy, Suspense, Fragment } from 'react';\nimport { Route, Link, Switch } from 'react-router-dom';\n\nimport utilities from '../../utilities/index.js';\n\nimport './Menu.css';\n\nconst NAV_NAMES = ['slack', 'medium', 'github', 'twitter', 'facebook'];\n\nconst Slack = lazy(() => import('../../components/Navs/Slack/Slack'));\n\nconst Menu = props => {\n    return (\n        <>\n            {/* Slack Component */}\n            <Route\n                path=\"/slack\"\n                render={props => {\n                    return (\n                        <Suspense fallback={<div>loading component</div>}>\n                            <Slack />\n                        </Suspense>\n                    );\n                }}\n            />\n            <div className=\"menu\">\n                <ul className=\"menu__list\">\n                    {NAV_NAMES.map(name => {\n                        return (\n                            <li key={name} className=\"menu__link\">\n                                <Link\n                                    to={`/${name}`}\n                                    className={`menu__link--${name}`}\n                                >\n                                    {utilities.capitalize(name)}\n                                </Link>\n                            </li>\n                        );\n                    })}\n                </ul>\n                <p>Pick a brand to see its navbar created with CSS flexbox!</p>\n            </div>\n        </>\n    );\n};\n\nexport default Menu;\n"],"sourceRoot":""}